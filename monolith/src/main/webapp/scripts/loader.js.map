{
  "version": 3,
  "sources": ["../node_modules/src/lib/cache/cache.handler.ts", "../node_modules/src/lib/cache/cache.contract.ts", "../node_modules/src/lib/cache/global-cache.ts", "../node_modules/src/lib/cache/default-cache.ts", "../node_modules/src/lib/dom/dom.handler.ts", "../node_modules/src/lib/utils/path.ts", "../node_modules/src/lib/import-map/import-map.handler.ts", "../node_modules/src/lib/init-federation/init-federation.handler.ts", "../node_modules/src/lib/logging/log.handler.ts", "../node_modules/src/lib/logging/noop.logger.ts", "../node_modules/src/lib/native-federation.error.ts", "../node_modules/src/lib/remote-entry/remote-info.handler.ts", "../node_modules/src/lib/remote-entry/shared-info.handler.ts", "../node_modules/src/lib/remote-module/remote-module.handler.ts", "../node_modules/src/lib/resolver.ts", "../node_modules/src/lib/init-federation.ts", "../node_modules/src/lib/load-remote-module.ts", "../node_modules/src/lib/cache/index.ts", "../node_modules/src/lib/logging/console.logger.ts", "../src/loader.js"],
  "sourcesContent": ["import type { CacheEntryCreator, CacheEntryValue, CacheOf } from \"./cache.contract\";\n\ntype CacheHandler<TCache extends CacheOf<Record<keyof TCache, any>>> = {\n    fetch: <K extends keyof TCache>(key: K) => CacheEntryValue<TCache[K]>;\n    entry: <K extends keyof TCache>(key: K) => TCache[K];\n    get: () => TCache;\n    mutate: <K extends keyof TCache>(\n        key: K,\n        mutateFn: (v: CacheEntryValue<TCache[K]>) => CacheEntryValue<TCache[K]>\n    ) => CacheHandler<TCache>;\n}\n\nfunction cacheHandlerFactory<TCache extends CacheOf<Record<keyof TCache, any>>>(\n    _cache: TCache\n): CacheHandler<TCache> {\n    const entry = <K extends keyof TCache>(key: K): TCache[K] => {\n        return _cache[key];\n    };\n\n    const fetch = <K extends keyof TCache>(key: K): CacheEntryValue<TCache[K]> => {\n        return _cache[key].get();\n    };\n\n    const mutate = <K extends keyof TCache>(\n        key: K,\n        mutateFn: (v: CacheEntryValue<TCache[K]>) => CacheEntryValue<TCache[K]>\n    ): CacheHandler<TCache> => {\n        const newVal = mutateFn(fetch(key));\n        _cache[key].set(newVal);\n        return cacheHandlerFactory(_cache);\n    };\n\n    const get = (): TCache => _cache;\n\n    return { fetch, mutate, get, entry };\n}\n\nconst toCache = <Tprops extends Record<string, any>>(\n    props: Tprops,\n    cacheEntryCreator: CacheEntryCreator\n): CacheOf<Tprops> => {\n    return Object.entries(props).reduce(\n        (acc, [key, value]) => ({\n            ...acc,\n            [key]: cacheEntryCreator(key, value)\n        }),\n        {} as CacheOf<Tprops>\n    );\n};\n\nexport {toCache, cacheHandlerFactory, CacheHandler};", "import type { RemoteInfo } from \"../remote-entry/remote-info.contract\";\n\nconst NAMESPACE = \"__NATIVE_FEDERATION__\";\n\n/**\n * ENTRIES\n */\ntype CacheEntry<T> = {\n    set: (value: T) => CacheEntry<T>;\n    get: () => T;\n    exists: () => boolean;\n};\n\ntype CacheEntryValue<T> = T extends CacheEntry<infer U> ? U : never;\n\n\ntype CacheOf<T> = {\n    [K in keyof T]: CacheEntry<T[K]>;\n};\n\ntype CacheExtension = CacheOf<Record<string, any>>;\n\ntype CacheEntryCreator = <T>(key: string, initialValue: T) => CacheEntry<T>;\n\n/**\n * DEFAULT STORED PROPERTIES\n */\ntype NativeFederationProps = {\n    externals: Record<string, string>;\n    remoteNamesToRemote: Record<string, RemoteInfo>;\n    baseUrlToRemoteNames: Record<string, string>;\n}\n\ntype NativeFederationCache = CacheOf<NativeFederationProps>\n\nexport {NAMESPACE, CacheEntryValue, CacheEntry, CacheExtension, CacheOf, NativeFederationProps, NativeFederationCache, CacheEntryCreator}", "import { type CacheEntryCreator, NAMESPACE, type CacheEntry, type NativeFederationProps, type CacheOf } from \"./cache.contract\";\nimport { toCache } from \"./cache.handler\";\n\ntype GlobalCache = {[NAMESPACE]: Record<string, unknown>;};\n\nconst globalCacheEntry: CacheEntryCreator = <T>(key: string, _fallback: T) => {\n    if (!(globalThis as unknown as GlobalCache)[NAMESPACE]) {\n        (globalThis as unknown as GlobalCache)[NAMESPACE] = {};\n    }\n    const namespace = (globalThis as unknown as GlobalCache)[NAMESPACE];\n    \n    const entry = {\n        get(): T {\n            return (namespace[key] as T) ?? _fallback;\n        },\n        \n        set(value: T): CacheEntry<T> {\n            namespace[key] = value;\n            return entry;\n        },\n        \n        exists(): boolean {\n            return key in namespace;\n        }\n    };\n\n    return entry;\n}\n\nconst createGlobalCache = <TCache extends NativeFederationProps>(cache: TCache): CacheOf<TCache> => {\n    return toCache(cache, globalCacheEntry)\n}\n\nexport {globalCacheEntry, createGlobalCache};", "import type { NativeFederationCache, NativeFederationProps } from './cache.contract';\nimport { toCache } from './cache.handler';\nimport { globalCacheEntry } from './global-cache';\n\nconst DEFAULT_PROPS: NativeFederationProps = {\n    externals: {},\n    remoteNamesToRemote: {},\n    baseUrlToRemoteNames: {}\n}\n\nconst DEFAULT_CACHE: NativeFederationCache = toCache(DEFAULT_PROPS, globalCacheEntry);\n\nexport {DEFAULT_CACHE, DEFAULT_PROPS};", "import type { ImportMap } from \"../import-map/import-map.contract\";\n\ntype DomHandler = {\n    createImportMap: (map: ImportMap) => ImportMap,\n    importModule: (url: string) => Promise<any>\n}\n\nconst domHandlerFactory = (): DomHandler => {\n\n    const createImportMap = (map: ImportMap): ImportMap => {\n        document.head.appendChild(\n            Object.assign(document.createElement('script'), {\n                type: 'importmap-shim',\n                innerHTML: JSON.stringify(map),\n            })\n        );\n        return map;\n    }\n\n    const importModule = async <T = any>(url: string): Promise<T> => {\n        return (globalThis as any).importShim(url);\n    }\n\n    return {createImportMap, importModule};\n}\n\nexport {domHandlerFactory, DomHandler};", "const getDir = (url: string): string => {\n    const parts = url.split('/');\n    parts.pop();\n    return parts.join('/');\n}\n\nconst join = (pathA: string, pathB: string): string => {\n    pathA = (pathA.startsWith('/')) ? pathA.slice(1) : pathA;\n    pathB = (pathB.endsWith('/')) ? pathB.slice(0, -1) : pathB;\n    return `${pathA}/${pathB}`;\n}\n\nexport {getDir, join}", "import type { ImportMap } from \"./import-map.contract\";\nimport type { RemoteInfo } from \"../remote-entry/remote-info.contract\";\nimport type { SharedInfoHandler } from \"../remote-entry/shared-info.handler\";\nimport * as _path from \"../utils/path\";\n\ntype ImportMapHandler = {\n    toImportMap: (remoteInfo: RemoteInfo, remoteName?: string) => ImportMap,\n    createEmpty: () => ImportMap,\n    merge: (maps: ImportMap[]) => ImportMap\n}\n\nconst importMapHandlerFactory = (sharedInfoHandler: SharedInfoHandler): ImportMapHandler => {\n    \n    const createEmpty = (): ImportMap => ({\n        imports: {},\n        scopes: {}\n    })\n\n    const merge = (maps: ImportMap[]) => {\n        return maps.reduce(\n            (acc: ImportMap, map: ImportMap) => ({\n                imports: { ...acc.imports, ...map.imports },\n                scopes: { ...acc.scopes, ...map.scopes },\n            }),\n            createEmpty()\n        );\n    }\n\n    const getImports = (remoteInfo: RemoteInfo, remoteName: string) => {\n        return remoteInfo.exposes.reduce((acc,remote) => ({\n            ...acc, \n            [_path.join(remoteName, remote.key)]: _path.join(remoteInfo.baseUrl, remote.outFileName)\n        }), {});\n    }\n\n    const getScopedDeps = (remoteInfo: RemoteInfo) => {\n        return {[remoteInfo.baseUrl + '/']: sharedInfoHandler.mapSharedDeps(remoteInfo)}\n    }\n\n    const toImportMap = (remoteInfo: RemoteInfo, remoteName?: string): ImportMap => {\n        if(!remoteName) remoteName = remoteInfo.name as string;\n\n        return { \n            imports: getImports(remoteInfo, remoteName), \n            scopes: getScopedDeps(remoteInfo)\n        };\n    }\n\n    return {toImportMap, createEmpty, merge};\n}\n\nexport {importMapHandlerFactory, ImportMapHandler};", "import type { LogHandler } from '../logging/log.handler';\nimport type { DomHandler } from './../dom/dom.handler';\nimport type { ImportMap } from './../import-map/import-map.contract';\nimport type { ImportMapHandler } from './../import-map/import-map.handler';\nimport type { RemoteInfoHandler } from './../remote-entry/remote-info.handler';\nimport type { RemoteModuleHandler } from './../remote-module/remote-module.handler';\nimport type { InitFederation } from './init-federation.contract';\n\n\ntype InitFederationHandler = {\n    init: InitFederation\n}\n\nconst initFederationHandlerFactory = (\n    domHandler: DomHandler,\n    logger: LogHandler,\n    remoteInfoHandler: RemoteInfoHandler,\n    importMapHandler: ImportMapHandler,\n    remoteModuleLoader: RemoteModuleHandler\n): InitFederationHandler => {\n\n    const fetchRemotes = (remotesOrManifestUrl: string | Record<string, string> = {}): Promise<Record<string, string>> => {\n        return (typeof remotesOrManifestUrl === 'string')\n            ? fetch(remotesOrManifestUrl).then(r => r.json())\n            : Promise.resolve(remotesOrManifestUrl)\n    }\n\n    \n    const remoteToImportMap = ([remoteName, remoteEntryUrl]: [string,string]) => {\n        return remoteInfoHandler.loadRemoteInfo(remoteEntryUrl, remoteName)\n            .then(info => importMapHandler.toImportMap(info, remoteName))\n            .catch(_ => {\n                logger.warn(`Error loading remoteEntry for ${remoteName} at '${remoteEntryUrl}', skipping module`);\n                return importMapHandler.createEmpty();\n            })\n    }\n\n    const createImportMapFromRemotes = (remotes: Record<string, string>): Promise<ImportMap> => {\n        return Promise\n            .all(Object.entries(remotes).map(remoteToImportMap))\n            .then(importMapHandler.merge);\n    }\n\n    const init = (remotesOrManifestUrl: string | Record<string, string> = {}) => {\n        return fetchRemotes(remotesOrManifestUrl)\n            .then(createImportMapFromRemotes)\n            .then(domHandler.createImportMap)\n            .then(importMap => ({\n                importMap,\n                load: remoteModuleLoader.load\n            }))\n    }\n\n    return {init}\n}\n\nexport { InitFederationHandler, initFederationHandlerFactory }", "\nconst LogLevel = {\n    debug: 0,\n    warn: 1,\n    error: 2\n}\n\ntype LogType = keyof typeof LogLevel;\n\ntype LogHandler = Record<LogType, (msg: string) => void>;\n\nconst logHandlerFactory = (minLevel: LogType, logger: LogHandler): LogHandler => {\n  const logTypes = Object.keys(LogLevel)\n    .filter(key => isNaN(Number(key))) as LogType[];\n  \n  return logTypes.reduce((acc, logType) => {    \n    return {\n      ...acc,\n      [logType]: (message: string) => {\n        if (LogLevel[logType] >= LogLevel[minLevel]) {\n          logger[logType](message);\n        }\n      }\n    };\n  }, {} as LogHandler);\n};\n\n  export { LogType, LogHandler, logHandlerFactory };", "import type { LogHandler } from \"./log.handler\"\n\nconst noopLogger: LogHandler = ({\n    debug: (_: string) => {},\n    error: (_: string) => {},\n    warn: (_: string) => {},\n})\n\nexport { noopLogger }", "class NFError extends Error {\n    constructor(message: string) {\n      super(message); \n      this.name = \"NFError\"; \n    }\n}\n\nexport {NFError}", "import type { RemoteInfo } from \"./remote-info.contract\";\nimport type { SharedInfoHandler } from \"./shared-info.handler\";\nimport type { NativeFederationCache } from \"../cache/cache.contract\";\nimport type { CacheHandler } from \"../cache/cache.handler\";\nimport type { LogHandler } from \"../logging/log.handler\";\nimport { NFError } from \"../native-federation.error\";\nimport * as _path from \"../utils/path\";\n\ntype RemoteInfoHandler = {\n    loadRemoteInfo: (remoteEntryUrl?: string, remoteName?: string) => Promise<RemoteInfo>\n}\n\nconst remoteInfoHandlerFactory = (\n    cacheHandler: CacheHandler<NativeFederationCache>, \n    logger: LogHandler,\n    dependencyHandler: SharedInfoHandler,\n): RemoteInfoHandler => {\n\n    const fromEntryJson = (entryUrl: string): Promise<RemoteInfo> => {\n        return fetch(entryUrl)\n            .then(r => r.json() as unknown as RemoteInfo)\n            .then(cfg => {\n                return {...cfg, baseUrl: _path.getDir(entryUrl)}\n            })\n    }\n\n    const addRemoteModuleToCache = (remoteInfo: RemoteInfo, remoteName: string): RemoteInfo => {\n        cacheHandler.mutate(\"remoteNamesToRemote\", v => ({...v, [remoteName]: remoteInfo}));\n        cacheHandler.mutate(\"baseUrlToRemoteNames\", v => ({...v, [remoteInfo.baseUrl]: remoteName}));\n\n        logger.debug(`Added remote '${remoteName}' to the cache.`);\n\n        return remoteInfo;\n    } \n\n    const loadRemoteInfo = (remoteEntryUrl?: string, remoteName?: string): Promise<RemoteInfo> => {\n        if(!remoteName && !!remoteEntryUrl) remoteName = cacheHandler.fetch(\"baseUrlToRemoteNames\")[_path.getDir(remoteEntryUrl)];\n        if(!remoteName) return Promise.reject(new NFError(\"Must provide valid remoteEntry or remoteName\"));\n\n        const cachedRemote = cacheHandler.fetch(\"remoteNamesToRemote\")[remoteName];\n        if (!!cachedRemote) {\n            logger.debug(`Remote '${cachedRemote.name}' retrieved from cache.`);\n            return Promise.resolve(cachedRemote)\n        };\n        if(!remoteEntryUrl) return Promise.reject(new NFError(`Module not registered, provide a valid remoteEntryUrl for '${remoteName}'`));\n\n        logger.debug(`Fetching '${remoteName}' remoteEntry.json from: ` + remoteEntryUrl);\n        return fromEntryJson(remoteEntryUrl)\n            .then(info => addRemoteModuleToCache(info, remoteName ?? info.name))\n            .then(dependencyHandler.addSharedDepsToCache)\n            .catch(e => {\n                logger.error(\"Failed to load remoteEntry: \" + (e?.message ?? e));\n                return Promise.reject(new NFError(\"Failed to load remoteEntry\"));\n            })\n    }\n\n    return {loadRemoteInfo};\n}\n\nexport {remoteInfoHandlerFactory, RemoteInfoHandler};", "import type { SharedInfo, RemoteInfo } from \"./remote-info.contract\";\nimport type { NativeFederationProps, CacheEntry } from \"../cache/cache.contract\";\nimport type { CacheHandler } from \"../cache/cache.handler\";\nimport * as _path from \"../utils/path\";\n\nconst toExternalKey = (shared: SharedInfo): string => {\n    return `${shared.packageName}@${shared.version}`;\n}\n\ntype SharedInfoHandler = {\n    mapSharedDeps: (remoteInfo: RemoteInfo) => Record<string, string>,\n    addSharedDepsToCache: (remoteInfo: RemoteInfo) => RemoteInfo\n}\n\nconst sharedInfoHandlerFactory = (\n    cache: CacheHandler<{\"externals\": CacheEntry<Record<string, string>>}>\n): SharedInfoHandler => {\n    const getCachedSharedDepRef = (dep: SharedInfo): string|undefined => {\n        return cache.fetch(\"externals\")[toExternalKey(dep)];\n    }\n\n    const mapSharedDeps = (remoteInfo: RemoteInfo) => {\n        return remoteInfo.shared.reduce((dependencies, moduleDep) => {\n            return {\n                ...dependencies,\n                [moduleDep.packageName]: getCachedSharedDepRef(moduleDep) || _path.join(remoteInfo.baseUrl, moduleDep.outFileName)\n            }\n        }, {});\n    }\n\n    const mapModuleDepsIntoSharedDepsList = (remoteInfo: RemoteInfo) => (sharedList: NativeFederationProps[\"externals\"]) => {\n        return remoteInfo.shared.reduce((existing, dep) => {\n            if(!existing[toExternalKey(dep)]) {\n                existing[toExternalKey(dep)] = _path.join(remoteInfo.baseUrl, dep.outFileName);\n            }\n            return existing;\n        }, sharedList)\n    }\n\n    const addSharedDepsToCache = (remoteInfo: RemoteInfo) => {\n        cache.mutate(\"externals\", mapModuleDepsIntoSharedDepsList(remoteInfo))\n        return remoteInfo;\n    }\n\n    return {mapSharedDeps, addSharedDepsToCache};\n}\n\nexport {toExternalKey, sharedInfoHandlerFactory, SharedInfoHandler};", "\nimport type { DomHandler } from \"../dom/dom.handler\";\nimport type { LogHandler } from \"../logging/log.handler\";\nimport { NFError } from \"../native-federation.error\";\nimport type { LoadRemoteModule, RemoteModuleOptions } from \"./remote-module.contract\";\nimport type { RemoteInfo } from \"../remote-entry/remote-info.contract\";\nimport type { RemoteInfoHandler } from \"../remote-entry/remote-info.handler\";\nimport * as _path from \"../utils/path\";\n\ntype RemoteModuleHandler = {\n    load: LoadRemoteModule\n}\n\nconst remoteModuleHandlerFactory = (\n    logger: LogHandler,\n    remoteInfoHandler: RemoteInfoHandler,\n    domHandler: DomHandler\n): RemoteModuleHandler => {\n\n    const mapToRemoteModule = (\n        optionsOrRemoteName: RemoteModuleOptions | string,\n        exposedModule?: string\n    ): RemoteModuleOptions =>  {\n        if (typeof optionsOrRemoteName === 'string' && exposedModule) {\n            return {\n                remoteName: optionsOrRemoteName,\n                exposedModule,\n            };\n        } else if (typeof optionsOrRemoteName === 'object' && !exposedModule) {\n            return optionsOrRemoteName;\n        }\n        logger.error(`Failed to load remote module: exposedModule and/or remoteName not provided`)\n        throw new NFError('Failed to load remote module');\n    }\n\n    const getExposedModuleUrl = (remoteInfo: RemoteInfo, exposedModule: string): string => {    \n        const exposed = remoteInfo.exposes.find(e => e.key === exposedModule);\n        if (!exposed) {\n            logger.error(`Module '${exposedModule}'is not exposed in remote '${remoteInfo.name}'`)\n            throw new NFError('Failed to load remote module');\n        }\n    \n        return _path.join(remoteInfo.baseUrl, exposed.outFileName);\n    }\n\n    const load = (\n        remoteNameOrModule: RemoteModuleOptions | string,\n        exposedModule?: string\n    ): Promise<void> => {\n        const remoteModule = mapToRemoteModule(remoteNameOrModule, exposedModule);\n        logger.debug(`Loading module ${JSON.stringify(remoteModule)}`)\n\n        if(!remoteModule.remoteName || remoteModule.remoteName === \"\") throw new NFError('remoteName cannot be empty');\n        return remoteInfoHandler\n            .loadRemoteInfo(remoteModule.remoteEntry, remoteModule.remoteName)\n            .then(info => getExposedModuleUrl(info, remoteModule.exposedModule))\n            .then(url => {logger.debug(\"Importing module: \" + url); return url})\n            .then(domHandler.importModule)\n    }\n\n    return { load }\n}\n\n\n\nexport { remoteModuleHandlerFactory, RemoteModuleHandler, RemoteModuleOptions };", "import type { CacheExtension, NativeFederationCache } from \"./cache/cache.contract\";\nimport  { cacheHandlerFactory } from \"./cache/cache.handler\";\nimport { DEFAULT_CACHE } from \"./cache/default-cache\";\nimport { domHandlerFactory } from \"./dom/dom.handler\";\nimport { importMapHandlerFactory } from \"./import-map/import-map.handler\";\nimport { initFederationHandlerFactory } from \"./init-federation/init-federation.handler\";\nimport { logHandlerFactory, type LogType, type LogHandler } from \"./logging/log.handler\";\nimport { noopLogger } from \"./logging/noop.logger\";\nimport { remoteInfoHandlerFactory } from \"./remote-entry/remote-info.handler\";\nimport { sharedInfoHandlerFactory } from \"./remote-entry/shared-info.handler\";\nimport { remoteModuleHandlerFactory } from \"./remote-module/remote-module.handler\";\n\ntype Config<TCache extends NativeFederationCache = NativeFederationCache> = {\n    cache: TCache,\n    logger: LogHandler,\n    logLevel: LogType\n}\n\nconst defaultConfig = (o: Partial<Config<NativeFederationCache & CacheExtension>>): Config<NativeFederationCache & CacheExtension> => {\n    return {\n        cache: o.cache ?? DEFAULT_CACHE,\n        logger: o.logger ?? noopLogger,\n        logLevel: o.logLevel ?? \"error\"\n    }\n}\n\nconst resolver = <TCache extends NativeFederationCache & CacheExtension>(\n    {cache, logger, logLevel}: Config<TCache>\n) => {\n    // Base handlers\n    const domHandler = domHandlerFactory();\n    const cacheHandler = cacheHandlerFactory(cache);\n    const logHandler = logHandlerFactory(logLevel, logger)\n\n    // remote-entry\n    const sharedInfoHandler = sharedInfoHandlerFactory(cacheHandler);\n    const remoteInfoHandler = remoteInfoHandlerFactory(cacheHandler, logHandler, sharedInfoHandler);\n\n    // import map\n    const importMapHandler = importMapHandlerFactory(sharedInfoHandler);\n    \n    // remote-module\n    const remoteModuleHandler = remoteModuleHandlerFactory(logHandler, remoteInfoHandler, domHandler);\n\n    // Init federation\n    const initFederationHandler = initFederationHandlerFactory(domHandler, logHandler, remoteInfoHandler, importMapHandler, remoteModuleHandler);\n\n    return {\n        domHandler,\n        cacheHandler, \n        logHandler, \n        sharedInfoHandler, \n        remoteInfoHandler, \n        importMapHandler, \n        remoteModuleHandler,\n        initFederationHandler\n    };\n}\n\nexport {Config, defaultConfig, resolver};", "import type { ImportMap } from \"./import-map/import-map.contract\";\nimport type { LoadRemoteModule } from \"./remote-module/remote-module.contract\";\nimport { type Config, defaultConfig, resolver } from \"./resolver\";\n\n\nconst initFederation = (\n    remotesOrManifestUrl: string | Record<string, string> = {},\n    options: Partial<Config> = {}\n): Promise<{load: LoadRemoteModule, importMap: ImportMap}> => {   \n    const { initFederationHandler } = resolver(defaultConfig(options));\n    return initFederationHandler.init(remotesOrManifestUrl)\n}\n\nexport { initFederation };", "import type { LoadRemoteModule, RemoteModuleOptions } from \"./remote-module/remote-module.contract\";\nimport { remoteModuleHandlerFactory } from \"./remote-module/remote-module.handler\";\nimport { type Config, defaultConfig, resolver } from \"./resolver\";\n\nconst loadRemoteModule: LoadRemoteModule = (\n    remoteNameOrModule: RemoteModuleOptions | string,exposedModule?: string,\n    options: Partial<Config> = {}\n) => {\n    const {\n        logHandler,\n        remoteInfoHandler, \n        domHandler\n    } = resolver(defaultConfig(options));\n\n    const moduleLoader = remoteModuleHandlerFactory(logHandler, remoteInfoHandler, domHandler);\n    return moduleLoader.load(remoteNameOrModule, exposedModule);\n}\n\nexport { loadRemoteModule }", "export {DEFAULT_CACHE} from './default-cache';\n\nexport { CacheEntry, CacheOf, NAMESPACE } from './cache.contract';\nexport { CacheHandler, cacheHandlerFactory, toCache } from './cache.handler';\nexport { createGlobalCache } from './global-cache';", "import type { LogHandler } from \"./log.handler\"\n\nconst consoleLogger: LogHandler = ({\n    debug: (msg: string) => console.log(`[DEBUG]: ${msg}`),\n    error: (msg: string) => console.error(`[NF]: ${msg}`),\n    warn: (msg: string) => console.warn(`[NF]: ${msg}`),\n})\n\nexport {consoleLogger}", "import { initFederation } from 'vanilla-native-federation';\n\nconst initMicroFrontends = async (urlOrManifest, remotes) => {\n    performance.mark('nf:init');\n    if(typeof urlOrManifest === \"object\" && !remotes ){\n        remotes = Object.keys(urlOrManifest);\n    }\n\n    return initFederation(urlOrManifest)\n        .then(({load}) => {\n            performance.mark('nf:config');\n            return Promise.all(remotes.map(r => load(r, \"./Component\")))\n        })\n        .then(_ => performance.mark('nf:loaded'));\n}\n\nexport { initMicroFrontends }"],
  "mappings": "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",
  "names": ["cacheHandlerFactory", "_cache", "entry", "key", "fetch", "mutateFn", "newVal", "toCache", "props", "cacheEntryCreator", "acc", "value", "NAMESPACE", "globalCacheEntry", "_fallback", "namespace", "createGlobalCache", "cache", "DEFAULT_PROPS", "DEFAULT_CACHE", "domHandlerFactory", "map", "url", "getDir", "parts", "join", "pathA", "pathB", "importMapHandlerFactory", "sharedInfoHandler", "createEmpty", "merge", "maps", "getImports", "remoteInfo", "remoteName", "remote", "getScopedDeps", "initFederationHandlerFactory", "domHandler", "logger", "remoteInfoHandler", "importMapHandler", "remoteModuleLoader", "fetchRemotes", "remotesOrManifestUrl", "r", "remoteToImportMap", "remoteEntryUrl", "info", "_", "createImportMapFromRemotes", "remotes", "importMap", "LogLevel", "logHandlerFactory", "minLevel", "logType", "message", "noopLogger", "NFError", "remoteInfoHandlerFactory", "cacheHandler", "dependencyHandler", "fromEntryJson", "entryUrl", "cfg", "addRemoteModuleToCache", "v", "cachedRemote", "e", "toExternalKey", "shared", "sharedInfoHandlerFactory", "getCachedSharedDepRef", "dep", "mapSharedDeps", "dependencies", "moduleDep", "mapModuleDepsIntoSharedDepsList", "sharedList", "existing", "remoteModuleHandlerFactory", "mapToRemoteModule", "optionsOrRemoteName", "exposedModule", "getExposedModuleUrl", "exposed", "remoteNameOrModule", "remoteModule", "defaultConfig", "o", "resolver", "logLevel", "logHandler", "remoteModuleHandler", "initFederationHandler", "initFederation", "options", "cache_exports", "__export", "DEFAULT_CACHE", "NAMESPACE", "cacheHandlerFactory", "createGlobalCache", "toCache", "initMicroFrontends", "urlOrManifest", "remotes", "initFederation", "load", "r", "_"]
}
