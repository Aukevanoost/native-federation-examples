{
  "version": 3,
  "sources": ["../node_modules/src/lib/native-federation.error.ts", "../node_modules/src/plugins/discovery/discovery/discovery.error.ts", "../node_modules/src/plugins/discovery/adapters/init-federation.adapter.ts", "../node_modules/src/lib/utils/version.ts", "../node_modules/src/plugins/discovery/adapters/remote-module.adapter.ts", "../node_modules/src/plugins/discovery/discovery/discovery.handler.ts", "../node_modules/src/plugins/discovery/mapper/noop.mapper.ts", "../node_modules/src/lib/cache/cache.handler.ts", "../node_modules/src/lib/cache/cache.contract.ts", "../node_modules/src/lib/cache/global-cache.ts", "../node_modules/src/lib/cache/default-cache.ts", "../node_modules/src/lib/dom/dom.handler.ts", "../node_modules/src/lib/utils/path.ts", "../node_modules/src/lib/import-map/import-map.handler.ts", "../node_modules/src/lib/init-federation/init-federation.handler.ts", "../node_modules/src/lib/logging/log.handler.ts", "../node_modules/src/lib/logging/noop.logger.ts", "../node_modules/src/lib/remote-entry/remote-info.handler.ts", "../node_modules/src/lib/remote-entry/shared-info.handler.ts", "../node_modules/src/lib/remote-module/remote-module.handler.ts", "../node_modules/src/lib/resolver.ts", "../node_modules/src/plugins/discovery/resolver.ts", "../node_modules/src/plugins/discovery/init-federation-from-discovery.ts", "../node_modules/src/plugins/discovery/mapper/manifest.mapper.ts", "../node_modules/src/lib/cache/cache.handler.ts", "../node_modules/src/lib/cache/cache.contract.ts", "../node_modules/src/lib/cache/global-cache.ts", "../node_modules/src/lib/cache/default-cache.ts", "../node_modules/src/lib/dom/dom.handler.ts", "../node_modules/src/lib/utils/path.ts", "../node_modules/src/lib/import-map/import-map.handler.ts", "../node_modules/src/lib/init-federation/init-federation.handler.ts", "../node_modules/src/lib/logging/log.handler.ts", "../node_modules/src/lib/logging/noop.logger.ts", "../node_modules/src/lib/native-federation.error.ts", "../node_modules/src/lib/remote-entry/remote-info.handler.ts", "../node_modules/src/lib/remote-entry/shared-info.handler.ts", "../node_modules/src/lib/remote-module/remote-module.handler.ts", "../node_modules/src/lib/resolver.ts", "../node_modules/src/lib/init-federation.ts", "../node_modules/src/lib/load-remote-module.ts", "../node_modules/src/lib/cache/index.ts", "../node_modules/src/lib/logging/console.logger.ts", "../src/loader-from-discovery.js"],
  "sourcesContent": ["class NFError extends Error {\n    constructor(message: string) {\n      super(message); \n      this.name = \"NFError\"; \n    }\n}\n\nexport {NFError}", "import { NFError } from \"../../../lib/native-federation.error\";\n\nclass NFDiscoveryError extends NFError {\n    constructor(message: string) {\n      super(message); \n      this.name = \"NFDiscoveryError\"; \n    }\n}\n\nexport {NFDiscoveryError}", "import type { RemoteModuleAdapter } from \"./remote-module.adapter\"\nimport type { InitFederationHandler } from \"../../../lib/init-federation/init-federation.handler\"\nimport type { LoadRemoteModule } from \"../../../lib/remote-module/remote-module.contract\"\nimport type { CacheResolveOptions, InitFederationFromDiscovery, RemoteModuleConfig } from \"../discovery/discovery.contract\"\nimport { NFDiscoveryError } from \"../discovery/discovery.error\"\nimport type { DiscoveryHandler } from \"../discovery/discovery.handler\"\n\ntype InitFederationAdapter = {\n    init: InitFederationFromDiscovery\n}\n\nconst initFederationAdapterFactory = (\n    initFederationHandler: InitFederationHandler,\n    discoveryHandler: DiscoveryHandler,\n    remoteModuleAdapter: RemoteModuleAdapter,\n): InitFederationAdapter => {\n\n    const getEntryPointUrls = (remotes: RemoteModuleConfig): Record<string, string> => {    \n        return Object.keys(remotes)\n            .reduce((nfConfig, mfe) => {\n                if(!remotes[mfe]) throw new NFDiscoveryError(`Could not preload remote '${mfe}', not available in discovery.`)\n                return {\n                    ...nfConfig, \n                    [mfe]: remotes[mfe].module.remoteEntry\n                }\n            }, {})\n    }\n\n    const verifyAndLoadModule = (load: LoadRemoteModule, remoteConfigs: RemoteModuleConfig) => {\n        return (remote: string, version?: string): Promise<any> => {\n            const remoteModule = remoteModuleAdapter.getIfInitialized(remoteConfigs, remote, version);\n            return load(remoteModule); \n        }\n    }\n\n    const init = (\n        discoveryManifestUrl: string,\n        resolveFromCache: CacheResolveOptions,\n     ) => {\n        return discoveryHandler\n            .fetchDiscoveredRemotes(discoveryManifestUrl, resolveFromCache)\n            .then(remoteConfigs => {\n                const entryPoints = getEntryPointUrls(remoteConfigs);\n\n                return initFederationHandler.init(entryPoints)\n                    .then(({load, importMap}) => ({\n                        load: verifyAndLoadModule(load, remoteConfigs), \n                        importMap,\n                        discovered: remoteConfigs\n                    }))\n            })\n    }\n    return {init};\n}\nexport { initFederationAdapterFactory, InitFederationAdapter }", "\nconst compareVersions = (v1: string, v2: string): number => {\n    try{\n        const v1Parts = v1.split('.');\n        const v2Parts = v2.split('.');\n    \n        for (let i = 0; i < Math.min(v1Parts.length, v2Parts.length); i++) {\n            if (Number(v1Parts[i]) > Number(v2Parts[i])) return 1;\n            if (Number(v1Parts[i]) < Number(v2Parts[i])) return -1;\n        }\n    }catch(_) {\n        return v1.localeCompare(v2);\n    }\n\n    return 0;\n};\n\nconst addLatestTag = (remotes: string[]): Record<string, \"latest\"> => {\n    return remotes.reduce((a,b) => ({...a, [b]: \"latest\"}), {});\n}\n\nconst getLatestVersion = (versions: string[]): string|undefined => {\n    return versions.sort(compareVersions)[0];\n}\n\nconst getLatestVersionBefore = (versions: string[], latest: string): string|undefined => {\n    return versions\n        .filter(v => compareVersions(v, latest) < 0)\n        .sort(compareVersions)[0];\n}\n\n\nexport {compareVersions, addLatestTag, getLatestVersion, getLatestVersionBefore};", "import type { CacheHandler } from \"../../../lib/cache/cache.handler\";\nimport type { RemoteModule } from \"../../../lib/remote-module/remote-module.contract\";\nimport { getLatestVersion } from \"../../../lib/utils/version\";\nimport type { DiscoveryCache, CachedRemoteVersions, RemoteModuleConfig } from \"../discovery/discovery.contract\";\nimport { NFDiscoveryError } from \"../discovery/discovery.error\";\n\ntype RemoteModuleAdapter = {\n    getIfInitialized: (\n        remoteConfigs: RemoteModuleConfig, \n        remoteName: string,\n        version?: string\n    ) => RemoteModule\n}\n\nconst remoteModuleAdapterFactory = (\n    cacheHandler: CacheHandler<DiscoveryCache>,\n): RemoteModuleAdapter => {\n    const cache = cacheHandler.entry(\"discovery\");\n\n    const tryGetLatestCachedVersion = (cachedRemote?: CachedRemoteVersions): string|undefined => {\n        return getLatestVersion(Object.keys(cachedRemote ?? {}));\n    }\n\n    const tryGetInitializedVersion = (remoteName: string, remoteConfigs: RemoteModuleConfig): string|undefined => {\n        return remoteConfigs[remoteName]?.version;\n    }\n\n    const getIfInitialized = (remoteConfigs: RemoteModuleConfig, remoteName: string, version?: string): RemoteModule => {\n        const cachedRemote = cache.get()[remoteName];\n        if(!cachedRemote || Object.keys(cachedRemote).length < 1) throw new NFDiscoveryError(`Remote '${remoteName}' is not initialized.`);\n\n        if(!version) version = tryGetInitializedVersion(remoteName, remoteConfigs) ?? tryGetLatestCachedVersion(cachedRemote);\n        if(!version) throw new NFDiscoveryError(`Remote '${remoteName}' contains 0 initialized versions.`);\n\n        const remote = cachedRemote[version]\n        if(!remote) throw new NFDiscoveryError(`Version '${version}' from remote '${remoteName}' is not initialized.`);\n\n        return remote.module; \n    }\n    return { getIfInitialized };\n}\n\nexport { remoteModuleAdapterFactory, RemoteModuleAdapter }", "import type { CacheResolveOptions, DiscoveredRemotes, DiscoveryCache, DiscoveryMapper, RemoteModuleConfig } from \"./discovery.contract\";\nimport { NFDiscoveryError } from \"./discovery.error\";\nimport type { CacheHandler } from \"../../../lib/cache/cache.handler\";\nimport type { LogHandler } from \"../../../lib/logging/log.handler\";\nimport { getLatestVersion, addLatestTag, getLatestVersionBefore } from \"../../../lib/utils/version\";\n\ntype DiscoveryHandler = {\n    fetchDiscoveredRemotes: (\n        discoveryManifestUrl: string, \n        resolveFromCache: CacheResolveOptions\n    ) => Promise<RemoteModuleConfig>\n}\n\nconst discoveryHandlerFactory = (\n    cacheHandler: CacheHandler<DiscoveryCache>,\n    logger: LogHandler,\n    mapper: DiscoveryMapper\n): DiscoveryHandler => {\n\n    const getCachedRemoteVersions = (resolveFromCache: CacheResolveOptions): RemoteModuleConfig|false => {\n        if (resolveFromCache === \"skip-cache\") {\n            logger.debug(\"[discovery] Skipping cached module configs\");\n            return false;\n        }\n        if (!cacheHandler.entry(\"discovery\").exists()){\n            logger.debug(\"[discovery] Discovery cache not found.\");\n            return false;\n        } \n\n        const cache = cacheHandler.fetch(\"discovery\");\n\n        const cachedRemoteConfigs: RemoteModuleConfig = {};\n\n        if(resolveFromCache === \"all-latest\"){\n            logger.debug(`[discovery] Adding 'latest' tag to cached remotes: [\"${Object.keys(cache).join('\", \"')}\"]`);\n            resolveFromCache = addLatestTag(Object.keys(cache));\n        } \n\n        for (const [remote, reqVersion] of Object.entries(resolveFromCache)) {\n\n            if(!cache[remote] || Object.keys(cache[remote]).length === 0) {\n                logger.warn(`[discovery] Remote ${remote} does not exist in cache. Omitting cache`);\n                return false;\n            }\n\n            const version = (reqVersion === \"latest\")\n                ? getLatestVersion(Object.keys(cache[remote]))!\n                : reqVersion;\n\n            if(!cache[remote][version]){\n                logger.warn(`[discovery] Version ${version} of ${remote} does not exist in cache. Omitting cache`);\n                return false;\n            }\n            cachedRemoteConfigs[remote] = cache[remote][version]!\n        }\n\n        return cachedRemoteConfigs;\n    }\n\n    const mapToRequestedVersion = (resolveVersions: Exclude<CacheResolveOptions, \"from-cache\">) => \n        (fetchedRemotes: DiscoveredRemotes): RemoteModuleConfig => {\n        if(resolveVersions === \"all-latest\" || Object.keys(resolveVersions).length < 1) {\n            resolveVersions = addLatestTag(Object.keys(fetchedRemotes));\n        }\n\n        return Object.entries(resolveVersions).reduce((acc,[remote, version]) => {\n            if (!fetchedRemotes[remote] || typeof fetchedRemotes[remote] !== 'object') \n                throw new NFDiscoveryError(`Remote '${remote}' is not available in discovery.`);\n\n            if (version === \"latest\") version = getLatestVersion(Object.keys(fetchedRemotes[remote]))!\n\n            if(!fetchedRemotes[remote][version]) {\n                logger.warn(`[discovery] Version '${version}' of remote '${remote}' is not available in discovery.`)\n\n                const fallbackVersion = getLatestVersionBefore(Object.keys(fetchedRemotes[remote]), version);\n                if (!fallbackVersion) {\n                    throw new NFDiscoveryError(`Remote '${remote}' has no versions available before '${version}' in discovery.`);\n                }\n\n                logger.warn(`[discovery] Remote ${remote} is falling back to version ${fallbackVersion}`)\n                version = fallbackVersion;\n            }\n\n            return {...acc, [remote]: fetchedRemotes[remote][version]!};\n        }, {} as RemoteModuleConfig)\n    }\n\n    const updateCachedRemoteConfigs = (newRemoteConfigs: RemoteModuleConfig) => {\n        cacheHandler.mutate(\"discovery\", cache => {\n            Object.entries(newRemoteConfigs).forEach(([remote, cfg]) => {\n                if(!cache[remote]) cache[remote] = {};\n                if(!cache[remote][cfg.version]) cache[remote][cfg.version] = cfg;\n            })\n            return cache;\n        });\n        return newRemoteConfigs;\n    }\n\n    const handleError = (msg: string) => (e: any) => {\n        logger.error(`${msg}: ${e?.message ?? e}`)\n        throw new NFDiscoveryError(\"[discovery] Could not load remote module configs\")\n    }\n\n    const fetchDiscoveredRemotes = (discoveryManifestUrl: string, resolveFromCache: CacheResolveOptions)\n        : Promise<RemoteModuleConfig> => {\n            const cachedVersions = getCachedRemoteVersions(resolveFromCache);\n            if (cachedVersions) {\n                logger.debug(\"[discovery] Retrieved remote configs from cache.\");\n\n                return Promise.resolve(cachedVersions);\n            }\n\n            logger.debug(`[discovery] Fetching discovery from ${discoveryManifestUrl}`);\n\n            if(resolveFromCache === \"all-latest\") resolveFromCache = {};\n            return fetch(discoveryManifestUrl)\n                .catch(handleError(\"Fetching manifest failed\"))\n                .then(response => mapper(response.json()))\n                .then(mapToRequestedVersion(resolveFromCache))\n                .catch(handleError(\"Mapping manifest failed\"))\n                .then(updateCachedRemoteConfigs)\n                .catch(handleError(\"Could not update cache\"))\n        }\n    return {fetchDiscoveredRemotes};\n}\n\nexport {discoveryHandlerFactory, DiscoveryHandler}", "import type { DiscoveredRemotes, DiscoveryMapper } from \"../discovery/discovery.contract\";\n\n\ntype NoopMapper = DiscoveryMapper<DiscoveredRemotes, DiscoveredRemotes>;\n\nexport const noopMapper: NoopMapper = (remotes) => remotes;", "import type { CacheEntryCreator, CacheEntryValue, CacheOf } from \"./cache.contract\";\n\ntype CacheHandler<TCache extends CacheOf<Record<keyof TCache, any>>> = {\n    fetch: <K extends keyof TCache>(key: K) => CacheEntryValue<TCache[K]>;\n    entry: <K extends keyof TCache>(key: K) => TCache[K];\n    get: () => TCache;\n    mutate: <K extends keyof TCache>(\n        key: K,\n        mutateFn: (v: CacheEntryValue<TCache[K]>) => CacheEntryValue<TCache[K]>\n    ) => CacheHandler<TCache>;\n}\n\nfunction cacheHandlerFactory<TCache extends CacheOf<Record<keyof TCache, any>>>(\n    _cache: TCache\n): CacheHandler<TCache> {\n    const entry = <K extends keyof TCache>(key: K): TCache[K] => {\n        return _cache[key];\n    };\n\n    const fetch = <K extends keyof TCache>(key: K): CacheEntryValue<TCache[K]> => {\n        return _cache[key].get();\n    };\n\n    const mutate = <K extends keyof TCache>(\n        key: K,\n        mutateFn: (v: CacheEntryValue<TCache[K]>) => CacheEntryValue<TCache[K]>\n    ): CacheHandler<TCache> => {\n        const newVal = mutateFn(fetch(key));\n        _cache[key].set(newVal);\n        return cacheHandlerFactory(_cache);\n    };\n\n    const get = (): TCache => _cache;\n\n    return { fetch, mutate, get, entry };\n}\n\nconst toCache = <Tprops extends Record<string, any>>(\n    props: Tprops,\n    cacheEntryCreator: CacheEntryCreator\n): CacheOf<Tprops> => {\n    return Object.entries(props).reduce(\n        (acc, [key, value]) => ({\n            ...acc,\n            [key]: cacheEntryCreator(key, value)\n        }),\n        {} as CacheOf<Tprops>\n    );\n};\n\nexport {toCache, cacheHandlerFactory, CacheHandler};", "import type { RemoteInfo } from \"../remote-entry/remote-info.contract\";\n\nconst NAMESPACE = \"__NATIVE_FEDERATION__\";\n\n/**\n * ENTRIES\n */\ntype CacheEntry<T> = {\n    set: (value: T) => CacheEntry<T>;\n    get: () => T;\n    exists: () => boolean;\n};\n\ntype CacheEntryValue<T> = T extends CacheEntry<infer U> ? U : never;\n\n\ntype CacheOf<T> = {\n    [K in keyof T]: CacheEntry<T[K]>;\n};\n\ntype CacheExtension = CacheOf<Record<string, any>>;\n\ntype CacheEntryCreator = <T>(key: string, initialValue: T) => CacheEntry<T>;\n\n/**\n * DEFAULT STORED PROPERTIES\n */\ntype NativeFederationProps = {\n    externals: Record<string, string>;\n    remoteNamesToRemote: Record<string, RemoteInfo>;\n    baseUrlToRemoteNames: Record<string, string>;\n}\n\ntype NativeFederationCache = CacheOf<NativeFederationProps>\n\nexport {NAMESPACE, CacheEntryValue, CacheEntry, CacheExtension, CacheOf, NativeFederationProps, NativeFederationCache, CacheEntryCreator}", "import { type CacheEntryCreator, NAMESPACE, type CacheEntry, type NativeFederationProps, type CacheOf } from \"./cache.contract\";\nimport { toCache } from \"./cache.handler\";\n\ntype GlobalCache = {[NAMESPACE]: Record<string, unknown>;};\n\nconst globalCacheEntry: CacheEntryCreator = <T>(key: string, _fallback: T) => {\n    if (!(globalThis as unknown as GlobalCache)[NAMESPACE]) {\n        (globalThis as unknown as GlobalCache)[NAMESPACE] = {};\n    }\n    const namespace = (globalThis as unknown as GlobalCache)[NAMESPACE];\n    \n    const entry = {\n        get(): T {\n            return (namespace[key] as T) ?? _fallback;\n        },\n        \n        set(value: T): CacheEntry<T> {\n            namespace[key] = value;\n            return entry;\n        },\n        \n        exists(): boolean {\n            return key in namespace;\n        }\n    };\n\n    return entry;\n}\n\nconst createGlobalCache = <TCache extends NativeFederationProps>(cache: TCache): CacheOf<TCache> => {\n    return toCache(cache, globalCacheEntry)\n}\n\nexport {globalCacheEntry, createGlobalCache};", "import type { NativeFederationCache, NativeFederationProps } from './cache.contract';\nimport { toCache } from './cache.handler';\nimport { globalCacheEntry } from './global-cache';\n\nconst DEFAULT_PROPS: NativeFederationProps = {\n    externals: {},\n    remoteNamesToRemote: {},\n    baseUrlToRemoteNames: {}\n}\n\nconst DEFAULT_CACHE: NativeFederationCache = toCache(DEFAULT_PROPS, globalCacheEntry);\n\nexport {DEFAULT_CACHE, DEFAULT_PROPS};", "import type { ImportMap } from \"../import-map/import-map.contract\";\n\ntype DomHandler = {\n    createImportMap: (map: ImportMap) => ImportMap,\n    importModule: (url: string) => Promise<any>\n}\n\nconst domHandlerFactory = (): DomHandler => {\n\n    const createImportMap = (map: ImportMap): ImportMap => {\n        document.head.appendChild(\n            Object.assign(document.createElement('script'), {\n                type: 'importmap-shim',\n                innerHTML: JSON.stringify(map),\n            })\n        );\n        return map;\n    }\n\n    const importModule = async <T = any>(url: string): Promise<T> => {\n        return (globalThis as any).importShim(url);\n    }\n\n    return {createImportMap, importModule};\n}\n\nexport {domHandlerFactory, DomHandler};", "const getDir = (url: string): string => {\n    const parts = url.split('/');\n    parts.pop();\n    return parts.join('/');\n}\n\nconst join = (pathA: string, pathB: string): string => {\n    pathA = (pathA.startsWith('/')) ? pathA.slice(1) : pathA;\n    pathB = (pathB.endsWith('/')) ? pathB.slice(0, -1) : pathB;\n    return `${pathA}/${pathB}`;\n}\n\nexport {getDir, join}", "import type { ImportMap } from \"./import-map.contract\";\nimport type { RemoteInfo } from \"../remote-entry/remote-info.contract\";\nimport type { SharedInfoHandler } from \"../remote-entry/shared-info.handler\";\nimport * as _path from \"../utils/path\";\n\ntype ImportMapHandler = {\n    toImportMap: (remoteInfo: RemoteInfo, remoteName?: string) => ImportMap,\n    createEmpty: () => ImportMap,\n    merge: (maps: ImportMap[]) => ImportMap\n}\n\nconst importMapHandlerFactory = (sharedInfoHandler: SharedInfoHandler): ImportMapHandler => {\n    \n    const createEmpty = (): ImportMap => ({\n        imports: {},\n        scopes: {}\n    })\n\n    const merge = (maps: ImportMap[]) => {\n        return maps.reduce(\n            (acc: ImportMap, map: ImportMap) => ({\n                imports: { ...acc.imports, ...map.imports },\n                scopes: { ...acc.scopes, ...map.scopes },\n            }),\n            createEmpty()\n        );\n    }\n\n    const getImports = (remoteInfo: RemoteInfo, remoteName: string) => {\n        return remoteInfo.exposes.reduce((acc,remote) => ({\n            ...acc, \n            [_path.join(remoteName, remote.key)]: _path.join(remoteInfo.baseUrl, remote.outFileName)\n        }), {});\n    }\n\n    const getScopedDeps = (remoteInfo: RemoteInfo) => {\n        return {[remoteInfo.baseUrl + '/']: sharedInfoHandler.mapSharedDeps(remoteInfo)}\n    }\n\n    const toImportMap = (remoteInfo: RemoteInfo, remoteName?: string): ImportMap => {\n        if(!remoteName) remoteName = remoteInfo.name as string;\n\n        return { \n            imports: getImports(remoteInfo, remoteName), \n            scopes: getScopedDeps(remoteInfo)\n        };\n    }\n\n    return {toImportMap, createEmpty, merge};\n}\n\nexport {importMapHandlerFactory, ImportMapHandler};", "import type { LogHandler } from '../logging/log.handler';\nimport type { DomHandler } from './../dom/dom.handler';\nimport type { ImportMap } from './../import-map/import-map.contract';\nimport type { ImportMapHandler } from './../import-map/import-map.handler';\nimport type { RemoteInfoHandler } from './../remote-entry/remote-info.handler';\nimport type { RemoteModuleHandler } from './../remote-module/remote-module.handler';\nimport type { InitFederation } from './init-federation.contract';\n\n\ntype InitFederationHandler = {\n    init: InitFederation\n}\n\nconst initFederationHandlerFactory = (\n    domHandler: DomHandler,\n    logger: LogHandler,\n    remoteInfoHandler: RemoteInfoHandler,\n    importMapHandler: ImportMapHandler,\n    remoteModuleLoader: RemoteModuleHandler\n): InitFederationHandler => {\n\n    const fetchRemotes = (remotesOrManifestUrl: string | Record<string, string> = {}): Promise<Record<string, string>> => {\n        return (typeof remotesOrManifestUrl === 'string')\n            ? fetch(remotesOrManifestUrl).then(r => r.json())\n            : Promise.resolve(remotesOrManifestUrl)\n    }\n\n    \n    const remoteToImportMap = ([remoteName, remoteEntryUrl]: [string,string]) => {\n        return remoteInfoHandler.loadRemoteInfo(remoteEntryUrl, remoteName)\n            .then(info => importMapHandler.toImportMap(info, remoteName))\n            .catch(_ => {\n                logger.warn(`Error loading remoteEntry for ${remoteName} at '${remoteEntryUrl}', skipping module`);\n                return importMapHandler.createEmpty();\n            })\n    }\n\n    const createImportMapFromRemotes = (remotes: Record<string, string>): Promise<ImportMap> => {\n        return Promise\n            .all(Object.entries(remotes).map(remoteToImportMap))\n            .then(importMapHandler.merge);\n    }\n\n    const init = (remotesOrManifestUrl: string | Record<string, string> = {}) => {\n        return fetchRemotes(remotesOrManifestUrl)\n            .then(createImportMapFromRemotes)\n            .then(domHandler.createImportMap)\n            .then(importMap => ({\n                importMap,\n                load: remoteModuleLoader.load\n            }))\n    }\n\n    return {init}\n}\n\nexport { InitFederationHandler, initFederationHandlerFactory }", "\nconst LogLevel = {\n    debug: 0,\n    warn: 1,\n    error: 2\n}\n\ntype LogType = keyof typeof LogLevel;\n\ntype LogHandler = Record<LogType, (msg: string) => void>;\n\nconst logHandlerFactory = (minLevel: LogType, logger: LogHandler): LogHandler => {\n  const logTypes = Object.keys(LogLevel)\n    .filter(key => isNaN(Number(key))) as LogType[];\n  \n  return logTypes.reduce((acc, logType) => {    \n    return {\n      ...acc,\n      [logType]: (message: string) => {\n        if (LogLevel[logType] >= LogLevel[minLevel]) {\n          logger[logType](message);\n        }\n      }\n    };\n  }, {} as LogHandler);\n};\n\n  export { LogType, LogHandler, logHandlerFactory };", "import type { LogHandler } from \"./log.handler\"\n\nconst noopLogger: LogHandler = ({\n    debug: (_: string) => {},\n    error: (_: string) => {},\n    warn: (_: string) => {},\n})\n\nexport { noopLogger }", "import type { RemoteInfo } from \"./remote-info.contract\";\nimport type { SharedInfoHandler } from \"./shared-info.handler\";\nimport type { NativeFederationCache } from \"../cache/cache.contract\";\nimport type { CacheHandler } from \"../cache/cache.handler\";\nimport type { LogHandler } from \"../logging/log.handler\";\nimport { NFError } from \"../native-federation.error\";\nimport * as _path from \"../utils/path\";\n\ntype RemoteInfoHandler = {\n    loadRemoteInfo: (remoteEntryUrl?: string, remoteName?: string) => Promise<RemoteInfo>\n}\n\nconst remoteInfoHandlerFactory = (\n    cacheHandler: CacheHandler<NativeFederationCache>, \n    logger: LogHandler,\n    dependencyHandler: SharedInfoHandler,\n): RemoteInfoHandler => {\n\n    const fromEntryJson = (entryUrl: string): Promise<RemoteInfo> => {\n        return fetch(entryUrl)\n            .then(r => r.json() as unknown as RemoteInfo)\n            .then(cfg => {\n                return {...cfg, baseUrl: _path.getDir(entryUrl)}\n            })\n    }\n\n    const addRemoteModuleToCache = (remoteInfo: RemoteInfo, remoteName: string): RemoteInfo => {\n        cacheHandler.mutate(\"remoteNamesToRemote\", v => ({...v, [remoteName]: remoteInfo}));\n        cacheHandler.mutate(\"baseUrlToRemoteNames\", v => ({...v, [remoteInfo.baseUrl]: remoteName}));\n\n        logger.debug(`Added remote '${remoteName}' to the cache.`);\n\n        return remoteInfo;\n    } \n\n    const loadRemoteInfo = (remoteEntryUrl?: string, remoteName?: string): Promise<RemoteInfo> => {\n        if(!remoteName && !!remoteEntryUrl) remoteName = cacheHandler.fetch(\"baseUrlToRemoteNames\")[_path.getDir(remoteEntryUrl)];\n        if(!remoteName) return Promise.reject(new NFError(\"Must provide valid remoteEntry or remoteName\"));\n\n        const cachedRemote = cacheHandler.fetch(\"remoteNamesToRemote\")[remoteName];\n        if (!!cachedRemote) {\n            logger.debug(`Remote '${cachedRemote.name}' retrieved from cache.`);\n            return Promise.resolve(cachedRemote)\n        };\n        if(!remoteEntryUrl) return Promise.reject(new NFError(`Module not registered, provide a valid remoteEntryUrl for '${remoteName}'`));\n\n        logger.debug(`Fetching '${remoteName}' remoteEntry.json from: ` + remoteEntryUrl);\n        return fromEntryJson(remoteEntryUrl)\n            .then(info => addRemoteModuleToCache(info, remoteName ?? info.name))\n            .then(dependencyHandler.addSharedDepsToCache)\n            .catch(e => {\n                logger.error(\"Failed to load remoteEntry: \" + (e?.message ?? e));\n                return Promise.reject(new NFError(\"Failed to load remoteEntry\"));\n            })\n    }\n\n    return {loadRemoteInfo};\n}\n\nexport {remoteInfoHandlerFactory, RemoteInfoHandler};", "import type { SharedInfo, RemoteInfo } from \"./remote-info.contract\";\nimport type { NativeFederationProps, CacheEntry } from \"../cache/cache.contract\";\nimport type { CacheHandler } from \"../cache/cache.handler\";\nimport * as _path from \"../utils/path\";\n\nconst toExternalKey = (shared: SharedInfo): string => {\n    return `${shared.packageName}@${shared.version}`;\n}\n\ntype SharedInfoHandler = {\n    mapSharedDeps: (remoteInfo: RemoteInfo) => Record<string, string>,\n    addSharedDepsToCache: (remoteInfo: RemoteInfo) => RemoteInfo\n}\n\nconst sharedInfoHandlerFactory = (\n    cache: CacheHandler<{\"externals\": CacheEntry<Record<string, string>>}>\n): SharedInfoHandler => {\n    const getCachedSharedDepRef = (dep: SharedInfo): string|undefined => {\n        return cache.fetch(\"externals\")[toExternalKey(dep)];\n    }\n\n    const mapSharedDeps = (remoteInfo: RemoteInfo) => {\n        return remoteInfo.shared.reduce((dependencies, moduleDep) => {\n            return {\n                ...dependencies,\n                [moduleDep.packageName]: getCachedSharedDepRef(moduleDep) || _path.join(remoteInfo.baseUrl, moduleDep.outFileName)\n            }\n        }, {});\n    }\n\n    const mapModuleDepsIntoSharedDepsList = (remoteInfo: RemoteInfo) => (sharedList: NativeFederationProps[\"externals\"]) => {\n        return remoteInfo.shared.reduce((existing, dep) => {\n            if(!existing[toExternalKey(dep)]) {\n                existing[toExternalKey(dep)] = _path.join(remoteInfo.baseUrl, dep.outFileName);\n            }\n            return existing;\n        }, sharedList)\n    }\n\n    const addSharedDepsToCache = (remoteInfo: RemoteInfo) => {\n        cache.mutate(\"externals\", mapModuleDepsIntoSharedDepsList(remoteInfo))\n        return remoteInfo;\n    }\n\n    return {mapSharedDeps, addSharedDepsToCache};\n}\n\nexport {toExternalKey, sharedInfoHandlerFactory, SharedInfoHandler};", "\nimport type { DomHandler } from \"../dom/dom.handler\";\nimport type { LogHandler } from \"../logging/log.handler\";\nimport { NFError } from \"../native-federation.error\";\nimport type { LoadRemoteModule, RemoteModuleOptions } from \"./remote-module.contract\";\nimport type { RemoteInfo } from \"../remote-entry/remote-info.contract\";\nimport type { RemoteInfoHandler } from \"../remote-entry/remote-info.handler\";\nimport * as _path from \"../utils/path\";\n\ntype RemoteModuleHandler = {\n    load: LoadRemoteModule\n}\n\nconst remoteModuleHandlerFactory = (\n    logger: LogHandler,\n    remoteInfoHandler: RemoteInfoHandler,\n    domHandler: DomHandler\n): RemoteModuleHandler => {\n\n    const mapToRemoteModule = (\n        optionsOrRemoteName: RemoteModuleOptions | string,\n        exposedModule?: string\n    ): RemoteModuleOptions =>  {\n        if (typeof optionsOrRemoteName === 'string' && exposedModule) {\n            return {\n                remoteName: optionsOrRemoteName,\n                exposedModule,\n            };\n        } else if (typeof optionsOrRemoteName === 'object' && !exposedModule) {\n            return optionsOrRemoteName;\n        }\n        logger.error(`Failed to load remote module: exposedModule and/or remoteName not provided`)\n        throw new NFError('Failed to load remote module');\n    }\n\n    const getExposedModuleUrl = (remoteInfo: RemoteInfo, exposedModule: string): string => {    \n        const exposed = remoteInfo.exposes.find(e => e.key === exposedModule);\n        if (!exposed) {\n            logger.error(`Module '${exposedModule}'is not exposed in remote '${remoteInfo.name}'`)\n            throw new NFError('Failed to load remote module');\n        }\n    \n        return _path.join(remoteInfo.baseUrl, exposed.outFileName);\n    }\n\n    const load = (\n        remoteNameOrModule: RemoteModuleOptions | string,\n        exposedModule?: string\n    ): Promise<void> => {\n        const remoteModule = mapToRemoteModule(remoteNameOrModule, exposedModule);\n        logger.debug(`Loading module ${JSON.stringify(remoteModule)}`)\n\n        if(!remoteModule.remoteName || remoteModule.remoteName === \"\") throw new NFError('remoteName cannot be empty');\n        return remoteInfoHandler\n            .loadRemoteInfo(remoteModule.remoteEntry, remoteModule.remoteName)\n            .then(info => getExposedModuleUrl(info, remoteModule.exposedModule))\n            .then(url => {logger.debug(\"Importing module: \" + url); return url})\n            .then(domHandler.importModule)\n    }\n\n    return { load }\n}\n\n\n\nexport { remoteModuleHandlerFactory, RemoteModuleHandler, RemoteModuleOptions };", "import type { CacheExtension, NativeFederationCache } from \"./cache/cache.contract\";\nimport  { cacheHandlerFactory } from \"./cache/cache.handler\";\nimport { DEFAULT_CACHE } from \"./cache/default-cache\";\nimport { domHandlerFactory } from \"./dom/dom.handler\";\nimport { importMapHandlerFactory } from \"./import-map/import-map.handler\";\nimport { initFederationHandlerFactory } from \"./init-federation/init-federation.handler\";\nimport { logHandlerFactory, type LogType, type LogHandler } from \"./logging/log.handler\";\nimport { noopLogger } from \"./logging/noop.logger\";\nimport { remoteInfoHandlerFactory } from \"./remote-entry/remote-info.handler\";\nimport { sharedInfoHandlerFactory } from \"./remote-entry/shared-info.handler\";\nimport { remoteModuleHandlerFactory } from \"./remote-module/remote-module.handler\";\n\ntype Config<TCache extends NativeFederationCache = NativeFederationCache> = {\n    cache: TCache,\n    logger: LogHandler,\n    logLevel: LogType\n}\n\nconst defaultConfig = (o: Partial<Config<NativeFederationCache & CacheExtension>>): Config<NativeFederationCache & CacheExtension> => {\n    return {\n        cache: o.cache ?? DEFAULT_CACHE,\n        logger: o.logger ?? noopLogger,\n        logLevel: o.logLevel ?? \"error\"\n    }\n}\n\nconst resolver = <TCache extends NativeFederationCache & CacheExtension>(\n    {cache, logger, logLevel}: Config<TCache>\n) => {\n    // Base handlers\n    const domHandler = domHandlerFactory();\n    const cacheHandler = cacheHandlerFactory(cache);\n    const logHandler = logHandlerFactory(logLevel, logger)\n\n    // remote-entry\n    const sharedInfoHandler = sharedInfoHandlerFactory(cacheHandler);\n    const remoteInfoHandler = remoteInfoHandlerFactory(cacheHandler, logHandler, sharedInfoHandler);\n\n    // import map\n    const importMapHandler = importMapHandlerFactory(sharedInfoHandler);\n    \n    // remote-module\n    const remoteModuleHandler = remoteModuleHandlerFactory(logHandler, remoteInfoHandler, domHandler);\n\n    // Init federation\n    const initFederationHandler = initFederationHandlerFactory(domHandler, logHandler, remoteInfoHandler, importMapHandler, remoteModuleHandler);\n\n    return {\n        domHandler,\n        cacheHandler, \n        logHandler, \n        sharedInfoHandler, \n        remoteInfoHandler, \n        importMapHandler, \n        remoteModuleHandler,\n        initFederationHandler\n    };\n}\n\nexport {Config, defaultConfig, resolver};", "import { initFederationAdapterFactory } from \"./adapters/init-federation.adapter\";\nimport { remoteModuleAdapterFactory } from \"./adapters/remote-module.adapter\";\nimport type { DiscoveryCache, CacheResolveOptions, DiscoveryMapper } from \"./discovery/discovery.contract\";\nimport { discoveryHandlerFactory } from \"./discovery/discovery.handler\";\nimport { noopMapper } from \"./mapper/noop.mapper\";\nimport { DEFAULT_CACHE } from \"../../lib/cache\";\nimport type { NativeFederationCache } from \"../../lib/cache/cache.contract\";\nimport { toCache } from \"../../lib/cache/cache.handler\";\nimport { globalCacheEntry } from \"../../lib/cache/global-cache\";\nimport { resolver as baseResolver, type Config, defaultConfig as baseConfig } from \"../../lib/resolver\";\n\n\ntype DiscoveryConfig = Config<NativeFederationCache & DiscoveryCache> & {\n    resolveFromCache: CacheResolveOptions,\n    discoveryMapper: DiscoveryMapper\n};\n\n\nconst defaultConfig = (o: Partial<DiscoveryConfig>): DiscoveryConfig => {\n    return {\n        ...baseConfig(o),\n        cache: o.cache ?? {\n            ...DEFAULT_CACHE, \n            ...toCache({discovery: {}}, globalCacheEntry)\n        },\n        resolveFromCache: o.resolveFromCache ?? \"all-latest\",\n        discoveryMapper: o.discoveryMapper ?? noopMapper\n    }\n}\n\n\nconst resolver = (\n    cfg: DiscoveryConfig\n) => {\n    const base = baseResolver(cfg);\n\n    const discoveryHandler = discoveryHandlerFactory(base.cacheHandler, base.logHandler, cfg.discoveryMapper);\n\n    const remoteModuleAdapter = remoteModuleAdapterFactory(base.cacheHandler);\n    const initFederationAdapter = initFederationAdapterFactory(base.initFederationHandler, discoveryHandler, remoteModuleAdapter)\n\n    return {\n        ...base,\n        discoveryHandler, \n        remoteModuleAdapter,\n        initFederationAdapter\n    };\n}\n\nexport { resolver, defaultConfig, DiscoveryConfig };", "import { type DiscoveryConfig, resolver, defaultConfig } from \"./resolver\"\n\nconst initFederationFromDiscovery = (\n    discoveryManifestUrl: string,\n    options: Partial<DiscoveryConfig> = {}\n) => {    \n    const cfg = defaultConfig(options);\n    const { initFederationAdapter } = resolver(cfg);\n    \n    return initFederationAdapter.init(discoveryManifestUrl, cfg.resolveFromCache);\n}\n\nexport { initFederationFromDiscovery};", "import type { DiscoveredRemotes, DiscoveryMapper, CachedRemoteVersions, CachedRemoteModuleCfg } from \"../discovery/discovery.contract\";\nimport type { DiscoveryManifest, ManifestMicroFrontends, ManifestRemoteModule } from \"../manifest/discovery-manifest.contract\";\n\ntype ManifestMapper = DiscoveryMapper<DiscoveryManifest>;\n\nconst manifestMapper: ManifestMapper = (manifest: DiscoveryManifest) => {\n    const mapRemoteModule = (remote: string, module: ManifestRemoteModule) \n        : CachedRemoteModuleCfg => ({\n            url: module.url,\n            version: module.metadata.version,\n            module: {\n                remoteName: remote,\n                remoteEntry: module.extras.nativefederation.remoteEntry,\n                exposedModule: module.extras.nativefederation.exposedModule,\n            }\n        })\n\n    const mapVersion = (remote: string, modules: ManifestRemoteModule[])\n        : CachedRemoteVersions => \n            modules.reduce((acc, module) => ({\n                ...acc, \n                [module.metadata.version]: mapRemoteModule(remote, module)\n            }), {})\n\n    const mapRemotes = (mfe: ManifestMicroFrontends)\n        : DiscoveredRemotes => \n            Object.entries(mfe)\n                .reduce((acc, [remote, cfg]) => ({\n                    ...acc, \n                    [remote]: mapVersion(remote, cfg)\n                }), {})\n\n    return mapRemotes(manifest.microFrontends)\n}\n\nexport {ManifestMapper, manifestMapper};\n", "import type { CacheEntryCreator, CacheEntryValue, CacheOf } from \"./cache.contract\";\n\ntype CacheHandler<TCache extends CacheOf<Record<keyof TCache, any>>> = {\n    fetch: <K extends keyof TCache>(key: K) => CacheEntryValue<TCache[K]>;\n    entry: <K extends keyof TCache>(key: K) => TCache[K];\n    get: () => TCache;\n    mutate: <K extends keyof TCache>(\n        key: K,\n        mutateFn: (v: CacheEntryValue<TCache[K]>) => CacheEntryValue<TCache[K]>\n    ) => CacheHandler<TCache>;\n}\n\nfunction cacheHandlerFactory<TCache extends CacheOf<Record<keyof TCache, any>>>(\n    _cache: TCache\n): CacheHandler<TCache> {\n    const entry = <K extends keyof TCache>(key: K): TCache[K] => {\n        return _cache[key];\n    };\n\n    const fetch = <K extends keyof TCache>(key: K): CacheEntryValue<TCache[K]> => {\n        return _cache[key].get();\n    };\n\n    const mutate = <K extends keyof TCache>(\n        key: K,\n        mutateFn: (v: CacheEntryValue<TCache[K]>) => CacheEntryValue<TCache[K]>\n    ): CacheHandler<TCache> => {\n        const newVal = mutateFn(fetch(key));\n        _cache[key].set(newVal);\n        return cacheHandlerFactory(_cache);\n    };\n\n    const get = (): TCache => _cache;\n\n    return { fetch, mutate, get, entry };\n}\n\nconst toCache = <Tprops extends Record<string, any>>(\n    props: Tprops,\n    cacheEntryCreator: CacheEntryCreator\n): CacheOf<Tprops> => {\n    return Object.entries(props).reduce(\n        (acc, [key, value]) => ({\n            ...acc,\n            [key]: cacheEntryCreator(key, value)\n        }),\n        {} as CacheOf<Tprops>\n    );\n};\n\nexport {toCache, cacheHandlerFactory, CacheHandler};", "import type { RemoteInfo } from \"../remote-entry/remote-info.contract\";\n\nconst NAMESPACE = \"__NATIVE_FEDERATION__\";\n\n/**\n * ENTRIES\n */\ntype CacheEntry<T> = {\n    set: (value: T) => CacheEntry<T>;\n    get: () => T;\n    exists: () => boolean;\n};\n\ntype CacheEntryValue<T> = T extends CacheEntry<infer U> ? U : never;\n\n\ntype CacheOf<T> = {\n    [K in keyof T]: CacheEntry<T[K]>;\n};\n\ntype CacheExtension = CacheOf<Record<string, any>>;\n\ntype CacheEntryCreator = <T>(key: string, initialValue: T) => CacheEntry<T>;\n\n/**\n * DEFAULT STORED PROPERTIES\n */\ntype NativeFederationProps = {\n    externals: Record<string, string>;\n    remoteNamesToRemote: Record<string, RemoteInfo>;\n    baseUrlToRemoteNames: Record<string, string>;\n}\n\ntype NativeFederationCache = CacheOf<NativeFederationProps>\n\nexport {NAMESPACE, CacheEntryValue, CacheEntry, CacheExtension, CacheOf, NativeFederationProps, NativeFederationCache, CacheEntryCreator}", "import { type CacheEntryCreator, NAMESPACE, type CacheEntry, type NativeFederationProps, type CacheOf } from \"./cache.contract\";\nimport { toCache } from \"./cache.handler\";\n\ntype GlobalCache = {[NAMESPACE]: Record<string, unknown>;};\n\nconst globalCacheEntry: CacheEntryCreator = <T>(key: string, _fallback: T) => {\n    if (!(globalThis as unknown as GlobalCache)[NAMESPACE]) {\n        (globalThis as unknown as GlobalCache)[NAMESPACE] = {};\n    }\n    const namespace = (globalThis as unknown as GlobalCache)[NAMESPACE];\n    \n    const entry = {\n        get(): T {\n            return (namespace[key] as T) ?? _fallback;\n        },\n        \n        set(value: T): CacheEntry<T> {\n            namespace[key] = value;\n            return entry;\n        },\n        \n        exists(): boolean {\n            return key in namespace;\n        }\n    };\n\n    return entry;\n}\n\nconst createGlobalCache = <TCache extends NativeFederationProps>(cache: TCache): CacheOf<TCache> => {\n    return toCache(cache, globalCacheEntry)\n}\n\nexport {globalCacheEntry, createGlobalCache};", "import type { NativeFederationCache, NativeFederationProps } from './cache.contract';\nimport { toCache } from './cache.handler';\nimport { globalCacheEntry } from './global-cache';\n\nconst DEFAULT_PROPS: NativeFederationProps = {\n    externals: {},\n    remoteNamesToRemote: {},\n    baseUrlToRemoteNames: {}\n}\n\nconst DEFAULT_CACHE: NativeFederationCache = toCache(DEFAULT_PROPS, globalCacheEntry);\n\nexport {DEFAULT_CACHE, DEFAULT_PROPS};", "import type { ImportMap } from \"../import-map/import-map.contract\";\n\ntype DomHandler = {\n    createImportMap: (map: ImportMap) => ImportMap,\n    importModule: (url: string) => Promise<any>\n}\n\nconst domHandlerFactory = (): DomHandler => {\n\n    const createImportMap = (map: ImportMap): ImportMap => {\n        document.head.appendChild(\n            Object.assign(document.createElement('script'), {\n                type: 'importmap-shim',\n                innerHTML: JSON.stringify(map),\n            })\n        );\n        return map;\n    }\n\n    const importModule = async <T = any>(url: string): Promise<T> => {\n        return (globalThis as any).importShim(url);\n    }\n\n    return {createImportMap, importModule};\n}\n\nexport {domHandlerFactory, DomHandler};", "const getDir = (url: string): string => {\n    const parts = url.split('/');\n    parts.pop();\n    return parts.join('/');\n}\n\nconst join = (pathA: string, pathB: string): string => {\n    pathA = (pathA.startsWith('/')) ? pathA.slice(1) : pathA;\n    pathB = (pathB.endsWith('/')) ? pathB.slice(0, -1) : pathB;\n    return `${pathA}/${pathB}`;\n}\n\nexport {getDir, join}", "import type { ImportMap } from \"./import-map.contract\";\nimport type { RemoteInfo } from \"../remote-entry/remote-info.contract\";\nimport type { SharedInfoHandler } from \"../remote-entry/shared-info.handler\";\nimport * as _path from \"../utils/path\";\n\ntype ImportMapHandler = {\n    toImportMap: (remoteInfo: RemoteInfo, remoteName?: string) => ImportMap,\n    createEmpty: () => ImportMap,\n    merge: (maps: ImportMap[]) => ImportMap\n}\n\nconst importMapHandlerFactory = (sharedInfoHandler: SharedInfoHandler): ImportMapHandler => {\n    \n    const createEmpty = (): ImportMap => ({\n        imports: {},\n        scopes: {}\n    })\n\n    const merge = (maps: ImportMap[]) => {\n        return maps.reduce(\n            (acc: ImportMap, map: ImportMap) => ({\n                imports: { ...acc.imports, ...map.imports },\n                scopes: { ...acc.scopes, ...map.scopes },\n            }),\n            createEmpty()\n        );\n    }\n\n    const getImports = (remoteInfo: RemoteInfo, remoteName: string) => {\n        return remoteInfo.exposes.reduce((acc,remote) => ({\n            ...acc, \n            [_path.join(remoteName, remote.key)]: _path.join(remoteInfo.baseUrl, remote.outFileName)\n        }), {});\n    }\n\n    const getScopedDeps = (remoteInfo: RemoteInfo) => {\n        return {[remoteInfo.baseUrl + '/']: sharedInfoHandler.mapSharedDeps(remoteInfo)}\n    }\n\n    const toImportMap = (remoteInfo: RemoteInfo, remoteName?: string): ImportMap => {\n        if(!remoteName) remoteName = remoteInfo.name as string;\n\n        return { \n            imports: getImports(remoteInfo, remoteName), \n            scopes: getScopedDeps(remoteInfo)\n        };\n    }\n\n    return {toImportMap, createEmpty, merge};\n}\n\nexport {importMapHandlerFactory, ImportMapHandler};", "import type { LogHandler } from '../logging/log.handler';\nimport type { DomHandler } from './../dom/dom.handler';\nimport type { ImportMap } from './../import-map/import-map.contract';\nimport type { ImportMapHandler } from './../import-map/import-map.handler';\nimport type { RemoteInfoHandler } from './../remote-entry/remote-info.handler';\nimport type { RemoteModuleHandler } from './../remote-module/remote-module.handler';\nimport type { InitFederation } from './init-federation.contract';\n\n\ntype InitFederationHandler = {\n    init: InitFederation\n}\n\nconst initFederationHandlerFactory = (\n    domHandler: DomHandler,\n    logger: LogHandler,\n    remoteInfoHandler: RemoteInfoHandler,\n    importMapHandler: ImportMapHandler,\n    remoteModuleLoader: RemoteModuleHandler\n): InitFederationHandler => {\n\n    const fetchRemotes = (remotesOrManifestUrl: string | Record<string, string> = {}): Promise<Record<string, string>> => {\n        return (typeof remotesOrManifestUrl === 'string')\n            ? fetch(remotesOrManifestUrl).then(r => r.json())\n            : Promise.resolve(remotesOrManifestUrl)\n    }\n\n    \n    const remoteToImportMap = ([remoteName, remoteEntryUrl]: [string,string]) => {\n        return remoteInfoHandler.loadRemoteInfo(remoteEntryUrl, remoteName)\n            .then(info => importMapHandler.toImportMap(info, remoteName))\n            .catch(_ => {\n                logger.warn(`Error loading remoteEntry for ${remoteName} at '${remoteEntryUrl}', skipping module`);\n                return importMapHandler.createEmpty();\n            })\n    }\n\n    const createImportMapFromRemotes = (remotes: Record<string, string>): Promise<ImportMap> => {\n        return Promise\n            .all(Object.entries(remotes).map(remoteToImportMap))\n            .then(importMapHandler.merge);\n    }\n\n    const init = (remotesOrManifestUrl: string | Record<string, string> = {}) => {\n        return fetchRemotes(remotesOrManifestUrl)\n            .then(createImportMapFromRemotes)\n            .then(domHandler.createImportMap)\n            .then(importMap => ({\n                importMap,\n                load: remoteModuleLoader.load\n            }))\n    }\n\n    return {init}\n}\n\nexport { InitFederationHandler, initFederationHandlerFactory }", "\nconst LogLevel = {\n    debug: 0,\n    warn: 1,\n    error: 2\n}\n\ntype LogType = keyof typeof LogLevel;\n\ntype LogHandler = Record<LogType, (msg: string) => void>;\n\nconst logHandlerFactory = (minLevel: LogType, logger: LogHandler): LogHandler => {\n  const logTypes = Object.keys(LogLevel)\n    .filter(key => isNaN(Number(key))) as LogType[];\n  \n  return logTypes.reduce((acc, logType) => {    \n    return {\n      ...acc,\n      [logType]: (message: string) => {\n        if (LogLevel[logType] >= LogLevel[minLevel]) {\n          logger[logType](message);\n        }\n      }\n    };\n  }, {} as LogHandler);\n};\n\n  export { LogType, LogHandler, logHandlerFactory };", "import type { LogHandler } from \"./log.handler\"\n\nconst noopLogger: LogHandler = ({\n    debug: (_: string) => {},\n    error: (_: string) => {},\n    warn: (_: string) => {},\n})\n\nexport { noopLogger }", "class NFError extends Error {\n    constructor(message: string) {\n      super(message); \n      this.name = \"NFError\"; \n    }\n}\n\nexport {NFError}", "import type { RemoteInfo } from \"./remote-info.contract\";\nimport type { SharedInfoHandler } from \"./shared-info.handler\";\nimport type { NativeFederationCache } from \"../cache/cache.contract\";\nimport type { CacheHandler } from \"../cache/cache.handler\";\nimport type { LogHandler } from \"../logging/log.handler\";\nimport { NFError } from \"../native-federation.error\";\nimport * as _path from \"../utils/path\";\n\ntype RemoteInfoHandler = {\n    loadRemoteInfo: (remoteEntryUrl?: string, remoteName?: string) => Promise<RemoteInfo>\n}\n\nconst remoteInfoHandlerFactory = (\n    cacheHandler: CacheHandler<NativeFederationCache>, \n    logger: LogHandler,\n    dependencyHandler: SharedInfoHandler,\n): RemoteInfoHandler => {\n\n    const fromEntryJson = (entryUrl: string): Promise<RemoteInfo> => {\n        return fetch(entryUrl)\n            .then(r => r.json() as unknown as RemoteInfo)\n            .then(cfg => {\n                return {...cfg, baseUrl: _path.getDir(entryUrl)}\n            })\n    }\n\n    const addRemoteModuleToCache = (remoteInfo: RemoteInfo, remoteName: string): RemoteInfo => {\n        cacheHandler.mutate(\"remoteNamesToRemote\", v => ({...v, [remoteName]: remoteInfo}));\n        cacheHandler.mutate(\"baseUrlToRemoteNames\", v => ({...v, [remoteInfo.baseUrl]: remoteName}));\n\n        logger.debug(`Added remote '${remoteName}' to the cache.`);\n\n        return remoteInfo;\n    } \n\n    const loadRemoteInfo = (remoteEntryUrl?: string, remoteName?: string): Promise<RemoteInfo> => {\n        if(!remoteName && !!remoteEntryUrl) remoteName = cacheHandler.fetch(\"baseUrlToRemoteNames\")[_path.getDir(remoteEntryUrl)];\n        if(!remoteName) return Promise.reject(new NFError(\"Must provide valid remoteEntry or remoteName\"));\n\n        const cachedRemote = cacheHandler.fetch(\"remoteNamesToRemote\")[remoteName];\n        if (!!cachedRemote) {\n            logger.debug(`Remote '${cachedRemote.name}' retrieved from cache.`);\n            return Promise.resolve(cachedRemote)\n        };\n        if(!remoteEntryUrl) return Promise.reject(new NFError(`Module not registered, provide a valid remoteEntryUrl for '${remoteName}'`));\n\n        logger.debug(`Fetching '${remoteName}' remoteEntry.json from: ` + remoteEntryUrl);\n        return fromEntryJson(remoteEntryUrl)\n            .then(info => addRemoteModuleToCache(info, remoteName ?? info.name))\n            .then(dependencyHandler.addSharedDepsToCache)\n            .catch(e => {\n                logger.error(\"Failed to load remoteEntry: \" + (e?.message ?? e));\n                return Promise.reject(new NFError(\"Failed to load remoteEntry\"));\n            })\n    }\n\n    return {loadRemoteInfo};\n}\n\nexport {remoteInfoHandlerFactory, RemoteInfoHandler};", "import type { SharedInfo, RemoteInfo } from \"./remote-info.contract\";\nimport type { NativeFederationProps, CacheEntry } from \"../cache/cache.contract\";\nimport type { CacheHandler } from \"../cache/cache.handler\";\nimport * as _path from \"../utils/path\";\n\nconst toExternalKey = (shared: SharedInfo): string => {\n    return `${shared.packageName}@${shared.version}`;\n}\n\ntype SharedInfoHandler = {\n    mapSharedDeps: (remoteInfo: RemoteInfo) => Record<string, string>,\n    addSharedDepsToCache: (remoteInfo: RemoteInfo) => RemoteInfo\n}\n\nconst sharedInfoHandlerFactory = (\n    cache: CacheHandler<{\"externals\": CacheEntry<Record<string, string>>}>\n): SharedInfoHandler => {\n    const getCachedSharedDepRef = (dep: SharedInfo): string|undefined => {\n        return cache.fetch(\"externals\")[toExternalKey(dep)];\n    }\n\n    const mapSharedDeps = (remoteInfo: RemoteInfo) => {\n        return remoteInfo.shared.reduce((dependencies, moduleDep) => {\n            return {\n                ...dependencies,\n                [moduleDep.packageName]: getCachedSharedDepRef(moduleDep) || _path.join(remoteInfo.baseUrl, moduleDep.outFileName)\n            }\n        }, {});\n    }\n\n    const mapModuleDepsIntoSharedDepsList = (remoteInfo: RemoteInfo) => (sharedList: NativeFederationProps[\"externals\"]) => {\n        return remoteInfo.shared.reduce((existing, dep) => {\n            if(!existing[toExternalKey(dep)]) {\n                existing[toExternalKey(dep)] = _path.join(remoteInfo.baseUrl, dep.outFileName);\n            }\n            return existing;\n        }, sharedList)\n    }\n\n    const addSharedDepsToCache = (remoteInfo: RemoteInfo) => {\n        cache.mutate(\"externals\", mapModuleDepsIntoSharedDepsList(remoteInfo))\n        return remoteInfo;\n    }\n\n    return {mapSharedDeps, addSharedDepsToCache};\n}\n\nexport {toExternalKey, sharedInfoHandlerFactory, SharedInfoHandler};", "\nimport type { DomHandler } from \"../dom/dom.handler\";\nimport type { LogHandler } from \"../logging/log.handler\";\nimport { NFError } from \"../native-federation.error\";\nimport type { LoadRemoteModule, RemoteModuleOptions } from \"./remote-module.contract\";\nimport type { RemoteInfo } from \"../remote-entry/remote-info.contract\";\nimport type { RemoteInfoHandler } from \"../remote-entry/remote-info.handler\";\nimport * as _path from \"../utils/path\";\n\ntype RemoteModuleHandler = {\n    load: LoadRemoteModule\n}\n\nconst remoteModuleHandlerFactory = (\n    logger: LogHandler,\n    remoteInfoHandler: RemoteInfoHandler,\n    domHandler: DomHandler\n): RemoteModuleHandler => {\n\n    const mapToRemoteModule = (\n        optionsOrRemoteName: RemoteModuleOptions | string,\n        exposedModule?: string\n    ): RemoteModuleOptions =>  {\n        if (typeof optionsOrRemoteName === 'string' && exposedModule) {\n            return {\n                remoteName: optionsOrRemoteName,\n                exposedModule,\n            };\n        } else if (typeof optionsOrRemoteName === 'object' && !exposedModule) {\n            return optionsOrRemoteName;\n        }\n        logger.error(`Failed to load remote module: exposedModule and/or remoteName not provided`)\n        throw new NFError('Failed to load remote module');\n    }\n\n    const getExposedModuleUrl = (remoteInfo: RemoteInfo, exposedModule: string): string => {    \n        const exposed = remoteInfo.exposes.find(e => e.key === exposedModule);\n        if (!exposed) {\n            logger.error(`Module '${exposedModule}'is not exposed in remote '${remoteInfo.name}'`)\n            throw new NFError('Failed to load remote module');\n        }\n    \n        return _path.join(remoteInfo.baseUrl, exposed.outFileName);\n    }\n\n    const load = (\n        remoteNameOrModule: RemoteModuleOptions | string,\n        exposedModule?: string\n    ): Promise<void> => {\n        const remoteModule = mapToRemoteModule(remoteNameOrModule, exposedModule);\n        logger.debug(`Loading module ${JSON.stringify(remoteModule)}`)\n\n        if(!remoteModule.remoteName || remoteModule.remoteName === \"\") throw new NFError('remoteName cannot be empty');\n        return remoteInfoHandler\n            .loadRemoteInfo(remoteModule.remoteEntry, remoteModule.remoteName)\n            .then(info => getExposedModuleUrl(info, remoteModule.exposedModule))\n            .then(url => {logger.debug(\"Importing module: \" + url); return url})\n            .then(domHandler.importModule)\n    }\n\n    return { load }\n}\n\n\n\nexport { remoteModuleHandlerFactory, RemoteModuleHandler, RemoteModuleOptions };", "import type { CacheExtension, NativeFederationCache } from \"./cache/cache.contract\";\nimport  { cacheHandlerFactory } from \"./cache/cache.handler\";\nimport { DEFAULT_CACHE } from \"./cache/default-cache\";\nimport { domHandlerFactory } from \"./dom/dom.handler\";\nimport { importMapHandlerFactory } from \"./import-map/import-map.handler\";\nimport { initFederationHandlerFactory } from \"./init-federation/init-federation.handler\";\nimport { logHandlerFactory, type LogType, type LogHandler } from \"./logging/log.handler\";\nimport { noopLogger } from \"./logging/noop.logger\";\nimport { remoteInfoHandlerFactory } from \"./remote-entry/remote-info.handler\";\nimport { sharedInfoHandlerFactory } from \"./remote-entry/shared-info.handler\";\nimport { remoteModuleHandlerFactory } from \"./remote-module/remote-module.handler\";\n\ntype Config<TCache extends NativeFederationCache = NativeFederationCache> = {\n    cache: TCache,\n    logger: LogHandler,\n    logLevel: LogType\n}\n\nconst defaultConfig = (o: Partial<Config<NativeFederationCache & CacheExtension>>): Config<NativeFederationCache & CacheExtension> => {\n    return {\n        cache: o.cache ?? DEFAULT_CACHE,\n        logger: o.logger ?? noopLogger,\n        logLevel: o.logLevel ?? \"error\"\n    }\n}\n\nconst resolver = <TCache extends NativeFederationCache & CacheExtension>(\n    {cache, logger, logLevel}: Config<TCache>\n) => {\n    // Base handlers\n    const domHandler = domHandlerFactory();\n    const cacheHandler = cacheHandlerFactory(cache);\n    const logHandler = logHandlerFactory(logLevel, logger)\n\n    // remote-entry\n    const sharedInfoHandler = sharedInfoHandlerFactory(cacheHandler);\n    const remoteInfoHandler = remoteInfoHandlerFactory(cacheHandler, logHandler, sharedInfoHandler);\n\n    // import map\n    const importMapHandler = importMapHandlerFactory(sharedInfoHandler);\n    \n    // remote-module\n    const remoteModuleHandler = remoteModuleHandlerFactory(logHandler, remoteInfoHandler, domHandler);\n\n    // Init federation\n    const initFederationHandler = initFederationHandlerFactory(domHandler, logHandler, remoteInfoHandler, importMapHandler, remoteModuleHandler);\n\n    return {\n        domHandler,\n        cacheHandler, \n        logHandler, \n        sharedInfoHandler, \n        remoteInfoHandler, \n        importMapHandler, \n        remoteModuleHandler,\n        initFederationHandler\n    };\n}\n\nexport {Config, defaultConfig, resolver};", "import type { ImportMap } from \"./import-map/import-map.contract\";\nimport type { LoadRemoteModule } from \"./remote-module/remote-module.contract\";\nimport { type Config, defaultConfig, resolver } from \"./resolver\";\n\n\nconst initFederation = (\n    remotesOrManifestUrl: string | Record<string, string> = {},\n    options: Partial<Config> = {}\n): Promise<{load: LoadRemoteModule, importMap: ImportMap}> => {   \n    const { initFederationHandler } = resolver(defaultConfig(options));\n    return initFederationHandler.init(remotesOrManifestUrl)\n}\n\nexport { initFederation };", "import type { LoadRemoteModule, RemoteModuleOptions } from \"./remote-module/remote-module.contract\";\nimport { remoteModuleHandlerFactory } from \"./remote-module/remote-module.handler\";\nimport { type Config, defaultConfig, resolver } from \"./resolver\";\n\nconst loadRemoteModule: LoadRemoteModule = (\n    remoteNameOrModule: RemoteModuleOptions | string,exposedModule?: string,\n    options: Partial<Config> = {}\n) => {\n    const {\n        logHandler,\n        remoteInfoHandler, \n        domHandler\n    } = resolver(defaultConfig(options));\n\n    const moduleLoader = remoteModuleHandlerFactory(logHandler, remoteInfoHandler, domHandler);\n    return moduleLoader.load(remoteNameOrModule, exposedModule);\n}\n\nexport { loadRemoteModule }", "export {DEFAULT_CACHE} from './default-cache';\n\nexport { CacheEntry, CacheOf, NAMESPACE } from './cache.contract';\nexport { CacheHandler, cacheHandlerFactory, toCache } from './cache.handler';\nexport { createGlobalCache } from './global-cache';", "import type { LogHandler } from \"./log.handler\"\n\nconst consoleLogger: LogHandler = ({\n    debug: (msg: string) => console.log(`[DEBUG]: ${msg}`),\n    error: (msg: string) => console.error(`[NF]: ${msg}`),\n    warn: (msg: string) => console.warn(`[NF]: ${msg}`),\n})\n\nexport {consoleLogger}", "import { initFederationFromDiscovery } from 'vanilla-native-federation/plugins/discovery';\nimport { consoleLogger } from 'vanilla-native-federation';\n\nconst initMicroFrontends = (url, logLevel = \"error\") => {\n    performance.mark('nf:init');\n    return initFederationFromDiscovery(url, {logLevel, logger: consoleLogger})\n        .then(mfe => {\n            performance.mark('nf:config');\n            return Promise.all(remotes.map(r => load(r, \"./Component\")))\n        })\n        .then(_ => performance.mark('nf:loaded'));\n}\n\nexport { initMicroFrontends };"],
  "mappings": "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",
  "names": ["NFError", "message", "NFDiscoveryError", "initFederationAdapterFactory", "initFederationHandler", "discoveryHandler", "remoteModuleAdapter", "getEntryPointUrls", "remotes", "nfConfig", "mfe", "verifyAndLoadModule", "load", "remoteConfigs", "remote", "version", "remoteModule", "discoveryManifestUrl", "resolveFromCache", "entryPoints", "importMap", "compareVersions", "v1", "v2", "v1Parts", "v2Parts", "i", "addLatestTag", "a", "b", "getLatestVersion", "versions", "getLatestVersionBefore", "latest", "v", "remoteModuleAdapterFactory", "cacheHandler", "cache", "tryGetLatestCachedVersion", "cachedRemote", "tryGetInitializedVersion", "remoteName", "discoveryHandlerFactory", "logger", "mapper", "getCachedRemoteVersions", "cachedRemoteConfigs", "reqVersion", "mapToRequestedVersion", "resolveVersions", "fetchedRemotes", "acc", "fallbackVersion", "updateCachedRemoteConfigs", "newRemoteConfigs", "cfg", "handleError", "msg", "e", "cachedVersions", "response", "noopMapper", "cacheHandlerFactory", "_cache", "entry", "key", "fetch", "mutateFn", "newVal", "toCache", "props", "cacheEntryCreator", "value", "NAMESPACE", "globalCacheEntry", "_fallback", "namespace", "DEFAULT_PROPS", "DEFAULT_CACHE", "domHandlerFactory", "map", "url", "getDir", "parts", "join", "pathA", "pathB", "importMapHandlerFactory", "sharedInfoHandler", "createEmpty", "merge", "maps", "getImports", "remoteInfo", "getScopedDeps", "initFederationHandlerFactory", "domHandler", "remoteInfoHandler", "importMapHandler", "remoteModuleLoader", "fetchRemotes", "remotesOrManifestUrl", "r", "remoteToImportMap", "remoteEntryUrl", "info", "_", "createImportMapFromRemotes", "LogLevel", "logHandlerFactory", "minLevel", "logType", "noopLogger", "remoteInfoHandlerFactory", "dependencyHandler", "fromEntryJson", "entryUrl", "addRemoteModuleToCache", "toExternalKey", "shared", "sharedInfoHandlerFactory", "getCachedSharedDepRef", "dep", "mapSharedDeps", "dependencies", "moduleDep", "mapModuleDepsIntoSharedDepsList", "sharedList", "existing", "remoteModuleHandlerFactory", "mapToRemoteModule", "optionsOrRemoteName", "exposedModule", "getExposedModuleUrl", "exposed", "remoteNameOrModule", "defaultConfig", "o", "resolver", "logLevel", "logHandler", "remoteModuleHandler", "base", "initFederationAdapter", "initFederationFromDiscovery", "options", "cacheHandlerFactory", "_cache", "entry", "key", "fetch", "mutateFn", "newVal", "toCache", "props", "cacheEntryCreator", "acc", "value", "NAMESPACE", "globalCacheEntry", "_fallback", "namespace", "createGlobalCache", "cache", "DEFAULT_PROPS", "DEFAULT_CACHE", "cache_exports", "__export", "DEFAULT_CACHE", "NAMESPACE", "cacheHandlerFactory", "createGlobalCache", "toCache", "consoleLogger", "msg", "initMicroFrontends", "url", "logLevel", "initFederationFromDiscovery", "consoleLogger", "mfe", "r", "_"]
}
